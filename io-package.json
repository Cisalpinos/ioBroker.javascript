{
  "common": {
    "name": "javascript",
    "title": "Script Engine",
    "titleLang": {
      "en": "Script Engine",
      "de": "Skriptausführung",
      "ru": "Скрипты",
      "pt": "Script Engine",
      "nl": "Script-engine",
      "fr": "Moteur de script",
      "it": "Motore di script",
      "es": "Motor de script",
      "pl": "Silnik skryptowy",
      "zh-cn": "脚本引擎"
    },
    "authors": [
      "bluefox <dogafox@gmail.com>",
      "hobbyquaker <hq@ccu.io>",
      "Apollon77 <iobroker@fischer-ka.de>",
      "AlCalzone"
    ],
    "version": "5.4.4",
    "news": {
      "5.4.3": {
        "en": "Fix handling of month schedules with given date list\nOptimize scheduling to make sure to not miss triggers if callbacks would need too long",
        "de": "Behandlung von Monatsplänen mit gegebener Datumsliste korrigiert\nOptimieren Sie die Planung, um sicherzustellen, dass Sie keine Trigger verpassen, wenn Rückrufe zu lange dauern würden",
        "ru": "Исправлена обработка месячных расписаний с заданным списком дат.\nОптимизируйте планирование, чтобы не пропустить триггеры, если обратные вызовы потребуются слишком долго.",
        "pt": "Corrige o manuseio de agendamentos mensais com uma lista de datas fornecida\nOtimize o agendamento para garantir que não perca os acionadores se os retornos de chamada precisarem de muito tempo",
        "nl": "Afhandeling van maandschema's met gegeven datumlijst repareren\nOptimaliseer de planning om ervoor te zorgen dat u geen triggers mist als terugbellen te lang zou duren",
        "fr": "Correction de la gestion des horaires mensuels avec une liste de dates donnée\nOptimisez la planification pour vous assurer de ne pas manquer les déclencheurs si les rappels prendraient trop de temps",
        "it": "Risolto il problema con la gestione delle pianificazioni mensili con l'elenco delle date specificato\nOttimizza la pianificazione per assicurarti di non perdere i trigger se i callback richiedessero troppo tempo",
        "es": "Arreglar el manejo de los horarios mensuales con la lista de fechas dada\nOptimice la programación para asegurarse de no perder los disparadores si las devoluciones de llamadas necesitaran demasiado tiempo",
        "pl": "Naprawiono obsługę harmonogramów miesięcznych z podaną listą dat\nZoptymalizuj harmonogram, aby nie przegapić wyzwalaczy, jeśli wywołania zwrotne będą wymagały zbyt dużo czasu",
        "zh-cn": "使用给定的日期列表修复月份时间表的处理\n优化调度以确保在回调需要太长时间时不会错过触发器"
      },
      "5.4.2": {
        "en": "Fix automatic start of Rules scripts when starting adapter",
        "de": "Automatisches Starten von Regelskripten beim Start des Adapters behoben",
        "ru": "Исправлен автоматический запуск скриптов Rules при запуске адаптера.",
        "pt": "Corrige o início automático de scripts de regras ao iniciar o adaptador",
        "nl": "Automatische start van Regelscripts repareren bij het starten van de adapter",
        "fr": "Correction du démarrage automatique des scripts de règles lors du démarrage de l'adaptateur",
        "it": "Risolto il problema con l'avvio automatico degli script delle regole all'avvio dell'adattatore",
        "es": "Arreglar el inicio automático de los scripts de reglas al iniciar el adaptador",
        "pl": "Napraw automatyczne uruchamianie skryptów reguł podczas uruchamiania adaptera",
        "zh-cn": "修复启动适配器时规则脚本的自动启动"
      },
      "5.4.1": {
        "en": "Fix blockly subscribes broken in 5.4.0",
        "de": "In 5.4.0 fehlerhafte Blockly-Abonnements behoben",
        "ru": "Исправить блочную подписку, сломанную в 5.4.0",
        "pt": "Corrigir assinaturas em bloco quebradas no 5.4.0",
        "nl": "Repareer blockly-abonnementen verbroken in 5.4.0",
        "fr": "Correction des abonnements bloqués cassés dans 5.4.0",
        "it": "Risolto il problema con gli abbonamenti bloccati interrotti nella 5.4.0",
        "es": "Arreglar suscripciones bloqueadas rotas en 5.4.0",
        "pl": "Napraw blokowe subskrypcje zepsute w 5.4.0",
        "zh-cn": "修复 5.4.0 中损坏的块订阅"
      },
      "5.4.0": {
        "en": "Automatically create missing folder objects when states are created using createState\nFix special characters in blockly subscribe logic\nFix timing issue where state updates could not be current on startup\nFix state name handing\nFix potential crash cases reported by Sentry",
        "de": "Automatisches Erstellen fehlender Ordnerobjekte, wenn Zustände mit createState erstellt werden\nKorrigieren Sie Sonderzeichen in der Blockly-Subscribe-Logik\nBehebung eines Zeitproblems, bei dem Statusaktualisierungen beim Start nicht aktuell sein konnten\nKorrigieren Sie die Übergabe von Staatsnamen\nBeheben Sie potenzielle Absturzfälle, die von Sentry gemeldet wurden",
        "ru": "Автоматически создавать отсутствующие объекты папок при создании состояний с помощью createState.\nИсправление специальных символов в логике блочной подписки\nИсправлена ошибка синхронизации, из-за которой обновления состояния не могли быть текущими при запуске.\nИсправить передачу имени штата\nИсправить потенциальные случаи сбоев, о которых сообщает Sentry.",
        "pt": "Crie automaticamente objetos de pasta ausentes quando os estados forem criados usando createState\nCorrige caracteres especiais na lógica de assinatura em bloco\nCorrige o problema de tempo em que as atualizações de estado não podiam ser atualizadas na inicialização\nCorrigir a entrega do nome do estado\nCorrigir possíveis casos de travamento relatados pelo Sentinela",
        "nl": "Automatisch ontbrekende mapobjecten maken wanneer staten worden gemaakt met createState\nSpeciale tekens corrigeren in logica voor blokkering van abonnementen\nProbleem met timing oplossen waarbij statusupdates niet actueel konden zijn bij het opstarten\nOverhandigen van staatsnaam repareren\nHerstel mogelijke crashgevallen gemeld door Sentry",
        "fr": "Créer automatiquement des objets de dossier manquants lors de la création d'états à l'aide de createState\nCorrection des caractères spéciaux dans la logique d'abonnement en bloc\nCorrection d'un problème de synchronisation où les mises à jour d'état ne pouvaient pas être à jour au démarrage\nCorrection de la gestion du nom de l'état\nCorrection des cas de plantage potentiels signalés par Sentry",
        "it": "Crea automaticamente oggetti cartella mancanti quando gli stati vengono creati utilizzando createState\nCorreggi i caratteri speciali nella logica di sottoscrizione a blocchi\nRisolto il problema dei tempi per cui gli aggiornamenti di stato non potevano essere aggiornati all'avvio\nRisolto il problema con la consegna del nome dello stato\nRisolvi potenziali casi di crash segnalati da Sentry",
        "es": "Cree automáticamente objetos de carpeta que faltan cuando se crean estados usando createState\nArreglar caracteres especiales en la lógica de suscripción en bloque\nSolucionar el problema de tiempo donde las actualizaciones de estado no podían estar actualizadas al inicio\nArreglar la entrega de nombres de estado\nSolucionar posibles casos de bloqueo informados por Sentry",
        "pl": "Automatycznie twórz brakujące obiekty folderów, gdy stany są tworzone za pomocą createState\nNapraw znaki specjalne w logice blokowania subskrypcji\nNapraw problem z czasem, w którym aktualizacje stanu nie mogą być aktualne podczas uruchamiania\nNapraw przekazywanie nazwy stanu\nNapraw potencjalne awarie zgłoszone przez Sentry",
        "zh-cn": "使用 createState 创建状态时自动创建缺少的文件夹对象\n修复块订阅逻辑中的特殊字符\n修复启动时状态更新无法为最新的计时问题\n修复状态名称处理\n修复 Sentry 报告的潜在崩溃案例"
      },
      "5.3.3": {
        "en": "Added async functions: createStateAsync, deleteStateAsync",
        "de": "Asynchrone Funktionen hinzugefügt: createStateAsync, deleteStateAsync",
        "ru": "Добавлены асинхронные функции: createStateAsync, deleteStateAsync.",
        "pt": "Funções assíncronas adicionadas: createStateAsync, deleteStateAsync",
        "nl": "Toegevoegde asynchrone functies: createStateAsync, deleteStateAsync",
        "fr": "Fonctions asynchrones ajoutées : createStateAsync, deleteStateAsync",
        "it": "Aggiunte funzioni asincrone: createStateAsync, deleteStateAsync",
        "es": "Funciones asincrónicas agregadas: createStateAsync, deleteStateAsync",
        "pl": "Dodano funkcje asynchroniczne: createStateAsync, deleteStateAsync",
        "zh-cn": "添加了异步函数：createStateAsync、deleteStateAsync"
      },
      "5.3.2": {
        "en": "fix problem that scripts were not starting when scriptsEnabled State was triggered (or startScript was used)\nMake sure callbacks on startScript/stopScript work and Async variants also resolve\nMake sure startScriptAsync, stopScriptAsync and runScriptAsync resolve in debug mode too",
        "de": "Behebung des Problems, dass Skripte nicht gestartet wurden, wenn scriptsEnabled State ausgelöst wurde (oder startScript verwendet wurde)\nStellen Sie sicher, dass Callbacks auf startScript/stopScript funktionieren und Async-Varianten ebenfalls aufgelöst werden\nStellen Sie sicher, dass startScriptAsync, stopScriptAsync und runScriptAsync auch im Debugmodus aufgelöst werden",
        "ru": "исправить проблему, из-за которой скрипты не запускались, когда срабатывало состояние scriptsEnabled (или использовался startScript)\nУбедитесь, что обратные вызовы на startScript/stopScript работают, а варианты Async также разрешаются.\nУбедитесь, что startScriptAsync, stopScriptAsync и runScriptAsync разрешаются и в режиме отладки.",
        "pt": "corrigir o problema que os scripts não estavam iniciando quando o estado scriptsEnabled foi acionado (ou startScript foi usado)\nCertifique-se de que os retornos de chamada no startScript/stopScript funcionam e as variantes Async também resolvem\nCertifique-se de que startScriptAsync, stopScriptAsync e runScriptAsync também resolvam no modo de depuração",
        "nl": "probleem oplossen dat scripts niet startten toen scriptsEnabled State werd geactiveerd (of startScript werd gebruikt)\nZorg ervoor dat callbacks op startScript/stopScript werken en dat Async-varianten ook worden opgelost\nZorg ervoor dat startScriptAsync, stopScriptAsync en runScriptAsync ook worden opgelost in de foutopsporingsmodus",
        "fr": "résout le problème que les scripts ne démarraient pas lorsque l'état scriptsEnabled était déclenché (ou que startScript était utilisé)\nAssurez-vous que les rappels sur startScript/stopScript fonctionnent et que les variantes Async se résolvent également\nAssurez-vous que startScriptAsync, stopScriptAsync et runScriptAsync se résolvent également en mode débogage",
        "it": "risolvere il problema per cui gli script non si avviavano quando è stato attivato lo stato scriptsEnabled (o è stato utilizzato startScript)\nAssicurati che anche i callback su startScript/stopScript funzionino e le varianti Async vengano risolte\nAssicurati che startScriptAsync, stopScriptAsync e runScriptAsync si risolvano anche in modalità di debug",
        "es": "solucionar el problema de que los scripts no se iniciaban cuando se activaba scriptsEnabled State (o se usaba startScript)\nAsegúrese de que las devoluciones de llamada en startScript/stopScript funcionen y las variantes asíncronas también se resuelvan\nAsegúrese de que startScriptAsync, stopScriptAsync y runScriptAsync también se resuelvan en modo de depuración.",
        "pl": "naprawienie problemu polegającego na tym, że skrypty nie uruchamiały się po wywołaniu scriptsEnabled State (lub użyciu startScript)\nUpewnij się, że wywołania zwrotne w startScript/stopScript działają, a warianty Async również się rozwiązują\nUpewnij się, że startScriptAsync, stopScriptAsync i runScriptAsync są również rozwiązywane w trybie debugowania",
        "zh-cn": "修复触发scriptsEnabled状态（或使用startScript）时脚本未启动的问题\n确保 startScript/stopScript 上的回调正常工作并且异步变体也可以解决\n确保 startScriptAsync、stopScriptAsync 和 runScriptAsync 也在调试模式下解析"
      }
    },
    "desc": {
      "en": "Javascript/Blockly Script Engine for ioBroker",
      "de": "Javascript/Blockly Skriptausführung für ioBroker",
      "ru": "Выполнение Javascript/Blockly скриптов для ioBroker"
    },
    "platform": "Javascript/Node.js",
    "mode": "daemon",
    "loglevel": "info",
    "icon": "javascript.png",
    "extIcon": "https://raw.githubusercontent.com/ioBroker/ioBroker.javascript/master/admin-config/javascript.png",
    "keywords": [
      "js",
      "javascript",
      "typescript",
      "coffeescript",
      "rules",
      "automate",
      "scriptengine",
      "blockly",
      "blokly"
    ],
    "materialize": true,
    "readme": "https://github.com/iobroker/ioBroker.javascript/blob/master/README.md",
    "enabled": true,
    "license": "MIT",
    "compact": true,
    "eraseOnUpload": true,
    "adminTab": {
      "singleton": true,
      "name": {
        "en": "Scripts",
        "de": "Skripte",
        "ru": "Скрипты"
      }
    },
    "docs": {
      "en": [
        "docs/en/javascript.md",
        "docs/en/blockly.md"
      ],
      "ru": [
        "docs/ru/blockly.md"
      ],
      "de": [
        "docs/de/usage.md",
        "docs/de/blockly.md"
      ]
    },
    "dependencies": [
      {
        "js-controller": ">=2.2.0"
      }
    ],
    "globalDependencies": [
      {
        "admin": ">=5.1.9"
      }
    ],
    "type": "logic",
    "messagebox": true,
    "logTransporter": true,
    "plugins": {
      "sentry": {
        "dsn": "https://f3b9740caaee4ee69eb68019d71526ff@sentry.iobroker.net/15"
      }
    },
    "tier": 1,
    "connectionType": "none",
    "dataSource": "none"
  },
  "native": {
    "latitude": "",
    "longitude": "",
    "enableSetObject": false,
    "enableSendToHost": false,
    "enableExec": false,
    "libraries": "",
    "libraryTypings": "",
    "subscribe": false,
    "useSystemGPS": true,
    "mirrorPath": "",
    "mirrorInstance": 0,
    "allowSelfSignedCerts": false,
    "sunriseEvent": "nightEnd",
    "sunriseOffset": 0,
    "sunriseLimitStart": "06:00",
    "sunriseLimitEnd": "12:00",
    "sunsetEvent": "dusk",
    "sunsetOffset": 0,
    "sunsetLimitStart": "18:00",
    "sunsetLimitEnd": "23:00"
  },
  "objects": [
    {
      "_id": "_design/script",
      "language": "javascript",
      "views": {
        "javascript": {
          "map": "function(doc) { if (doc.type === 'script' && doc.common.engineType.match(/^[jJ]ava[sS]cript|^[cC]offee[sS]cript|^[tT]ype[sS]cript|^Blockly|^Rules/)) emit(doc.common.name, doc); }"
        }
      }
    },
    {
      "_id": "script.js",
      "common": {
        "name": "js"
      },
      "type": "device",
      "native": {}
    },
    {
      "_id": "script.js.common",
      "common": {
        "name": "common"
      },
      "type": "channel",
      "native": {}
    },
    {
      "_id": "script.js.global",
      "common": {
        "name": "global"
      },
      "type": "channel",
      "native": {}
    }
  ],
  "instanceObjects": [
    {
      "_id": "variables",
      "common": {
        "name": "Useful variables"
      },
      "type": "channel",
      "native": {}
    },
    {
      "_id": "variables.isDayTime",
      "common": {
        "name": "Is day time",
        "type": "boolean",
        "read": true,
        "write": false,
        "role": "indicator"
      },
      "type": "state",
      "native": {}
    },
    {
      "_id": "variables.dayTime",
      "common": {
        "name": "Actual day time",
        "desc": "Like 13:34, you can set native.format12 to true to have 1:32",
        "type": "string",
        "read": true,
        "write": false,
        "role": "state"
      },
      "type": "state",
      "native": {
        "format12": false,
        "leadingZeros": true
      }
    },
    {
      "_id": "variables.rulesTour",
      "common": {
        "name": "Is tour done",
        "type": "boolean",
        "read": true,
        "write": false,
        "role": "state"
      },
      "type": "state",
      "native": {}
    },
    {
      "_id": "debug",
      "common": {
        "name": "Debug variables"
      },
      "type": "channel",
      "native": {}
    },
    {
      "_id": "debug.to",
      "common": {
        "name": "Send data to debugger",
        "type": "string",
        "read": false,
        "write": true,
        "role": "json"
      },
      "type": "state",
      "native": {}
    },
    {
      "_id": "debug.from",
      "common": {
        "name": "Data from debugger",
        "type": "string",
        "read": true,
        "write": false,
        "role": "json"
      },
      "type": "state",
      "native": {}
    },
    {
      "_id": "debug.rules",
      "common": {
        "name": "Data from engine to rules",
        "type": "string",
        "read": true,
        "write": false,
        "role": "json"
      },
      "type": "state",
      "native": {}
    }
  ]
}
